{"version":3,"sources":["../../src/js/horizontalScrollToElements.js"],"names":["horizontalScrollToElements","container","elements","startPosition","currentElement","maxElementNumber","length","scrollLeft","offsetLeft","e","preventDefault","scrollLeftMax","scrollWidth","clientWidth","deltaY","Math","min","max"],"mappings":";;AAAA;;;;;;;;;;;AAWA,IAAMA,6BAA6B,SAA7BA,0BAA6B,CAACC,SAAD,EAAYC,QAAZ,EAA4C;AAAA,MAAtBC,aAAsB,uEAAN,CAAM;;AAC7E,MAAIC,iBAAiBD,aAArB;AACA,MAAME,mBAAmBH,SAASI,MAAT,GAAkB,CAA3C;;AAEAL,YAAUM,UAAV,GAAuBL,SAASE,cAAT,EAAyBI,UAAhD;;AAEA,SAAO,aAAK;AACVC,MAAEC,cAAF;AACA,QAAMC,gBAAgBV,UAAUU,aAAV,IACpBV,UAAUW,WAAV,GAAwBX,UAAUY,WADpC;AAEA,QAAGJ,EAAEK,MAAF,GAAW,CAAd,EAAiB;AACf,UAAGb,UAAUM,UAAV,GAAuBI,aAA1B,EACEP,iBAAiBW,KAAKC,GAAL,CAASX,gBAAT,EAA2BD,iBAAiB,CAA5C,CAAjB;AACH,KAHD,MAGO;AACL,SAAG;AACDA,yBAAiBW,KAAKE,GAAL,CAAS,CAAT,EAAYb,iBAAiB,CAA7B,CAAjB;AACD,OAFD,QAEQF,SAASE,cAAT,EAAyBI,UAAzB,GAAsCG,aAF9C;AAGD;AACDV,cAAUM,UAAV,GAAuBL,SAASE,cAAT,EAAyBI,UAAhD;AACD,GAbD;AAcD,CApBD","file":"horizontalScrollToElements.js","sourcesContent":["/**\n * returns a callback for 'wheel' event\n * which scroll the elements under given container horizontally\n * to reach a start point of one of elements given\n *\n * @param {HTMLElement} container element to accept scroll events\n * @param {HTMLCollection} elements collection of elements that will work as scroll snap points\n * @param {number} startPosition if specified the callback will work with this number as the default position\n *\n * @return {callback}\n */\nconst horizontalScrollToElements = (container, elements, startPosition = 0) => {\n  let currentElement = startPosition;\n  const maxElementNumber = elements.length - 1;\n\n  container.scrollLeft = elements[currentElement].offsetLeft;\n\n  return e => {\n    e.preventDefault();\n    const scrollLeftMax = container.scrollLeftMax ||\n      container.scrollWidth - container.clientWidth;\n    if(e.deltaY > 0) {\n      if(container.scrollLeft < scrollLeftMax)\n        currentElement = Math.min(maxElementNumber, currentElement + 1);\n    } else {\n      do {\n        currentElement = Math.max(0, currentElement - 1);\n      } while(elements[currentElement].offsetLeft > scrollLeftMax);\n    }\n    container.scrollLeft = elements[currentElement].offsetLeft;\n  };\n};"]}